#!/usr/bin/env python3
"""
Simple Flask API server to serve product alerts to the frontend.

This server provides endpoints to access alerts generated by run_product_alerts_mvp.py
without requiring manual file uploads.

Usage:
    python api_server.py                    # Run on default port 5000
    python api_server.py --port 8000        # Run on custom port
"""

import argparse
import json
import os
from datetime import date, datetime, timedelta
from pathlib import Path
from typing import Optional, Dict, Any, List
from flask import Flask, jsonify, send_from_directory
from flask_cors import CORS

app = Flask(__name__)
CORS(app)  # Enable CORS for frontend access

ALERTS_DIR = Path("data/alerts")


def get_latest_alert_file() -> Optional[Path]:
    """Get the most recent alert JSON file."""
    if not ALERTS_DIR.exists():
        return None

    alert_files = list(ALERTS_DIR.glob("product_alerts_*.json"))
    if not alert_files:
        return None

    # Sort by modification time, most recent first
    alert_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
    return alert_files[0]


def get_alert_file_by_date(date_str: str) -> Optional[Path]:
    """Get alert file for a specific date."""
    alert_file = ALERTS_DIR / f"product_alerts_{date_str}.json"
    return alert_file if alert_file.exists() else None


def read_alert_file(file_path: Path) -> Optional[Dict[str, Any]]:
    """Read and parse an alert JSON file."""
    try:
        with open(file_path, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"Error reading alert file {file_path}: {e}")
        return None


@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint."""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'alerts_dir': str(ALERTS_DIR.absolute()),
        'alerts_dir_exists': ALERTS_DIR.exists()
    })


@app.route('/api/alerts/latest', methods=['GET'])
def get_latest_alerts():
    """Get the most recent alerts."""
    latest_file = get_latest_alert_file()

    if not latest_file:
        return jsonify({
            'error': 'No alerts found',
            'message': 'No alert files available. Run run_product_alerts_mvp.py to generate alerts.'
        }), 404

    data = read_alert_file(latest_file)
    if not data:
        return jsonify({
            'error': 'Failed to read alerts',
            'message': 'Alert file exists but could not be read.'
        }), 500

    return jsonify(data)


@app.route('/api/alerts/<date_str>', methods=['GET'])
def get_alerts_by_date(date_str: str):
    """Get alerts for a specific date (YYYY-MM-DD format)."""
    alert_file = get_alert_file_by_date(date_str)

    if not alert_file:
        return jsonify({
            'error': 'Alerts not found',
            'message': f'No alerts found for date {date_str}'
        }), 404

    data = read_alert_file(alert_file)
    if not data:
        return jsonify({
            'error': 'Failed to read alerts',
            'message': 'Alert file exists but could not be read.'
        }), 500

    return jsonify(data)


@app.route('/api/alerts/list', methods=['GET'])
def list_available_dates():
    """List all available alert dates."""
    if not ALERTS_DIR.exists():
        return jsonify({
            'dates': [],
            'message': 'No alerts directory found'
        })

    alert_files = list(ALERTS_DIR.glob("product_alerts_*.json"))

    dates = []
    for file_path in alert_files:
        # Extract date from filename: product_alerts_YYYY-MM-DD.json
        filename = file_path.stem  # Remove .json
        date_part = filename.replace('product_alerts_', '')

        try:
            # Validate it's a proper date
            datetime.strptime(date_part, '%Y-%m-%d')
            dates.append({
                'date': date_part,
                'file': file_path.name,
                'modified': datetime.fromtimestamp(file_path.stat().st_mtime).isoformat()
            })
        except ValueError:
            continue

    # Sort by date, most recent first
    dates.sort(key=lambda x: x['date'], reverse=True)

    return jsonify({
        'count': len(dates),
        'dates': dates
    })


@app.route('/api/alerts/summary', methods=['GET'])
def get_alerts_summary():
    """Get a summary of all available alerts."""
    if not ALERTS_DIR.exists():
        return jsonify({
            'total_files': 0,
            'latest_date': None,
            'total_alerts': 0,
            'severity_breakdown': {}
        })

    alert_files = list(ALERTS_DIR.glob("product_alerts_*.json"))

    if not alert_files:
        return jsonify({
            'total_files': 0,
            'latest_date': None,
            'total_alerts': 0,
            'severity_breakdown': {}
        })

    # Get latest file
    alert_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
    latest_file = alert_files[0]
    latest_data = read_alert_file(latest_file)

    total_alerts = 0
    severity_breakdown = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}

    if latest_data:
        total_alerts = latest_data.get('total_alerts', 0)
        for alert in latest_data.get('alerts', []):
            severity = alert.get('severity', '').lower()
            if severity in severity_breakdown:
                severity_breakdown[severity] += 1

    return jsonify({
        'total_files': len(alert_files),
        'latest_date': latest_data.get('date') if latest_data else None,
        'total_alerts': total_alerts,
        'severity_breakdown': severity_breakdown,
        'tracked_products': latest_data.get('tracked_products', []) if latest_data else [],
        'tracked_locations': latest_data.get('tracked_locations', []) if latest_data else []
    })


@app.errorhandler(404)
def not_found(error):
    """Handle 404 errors."""
    return jsonify({
        'error': 'Not found',
        'message': 'The requested resource was not found'
    }), 404


@app.errorhandler(500)
def internal_error(error):
    """Handle 500 errors."""
    return jsonify({
        'error': 'Internal server error',
        'message': 'An unexpected error occurred'
    }), 500


def main():
    parser = argparse.ArgumentParser(
        description="Product Alerts API Server",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument(
        "--port",
        type=int,
        default=5000,
        help="Port to run the server on (default: 5000)"
    )

    parser.add_argument(
        "--host",
        default="0.0.0.0",
        help="Host to bind to (default: 0.0.0.0)"
    )

    parser.add_argument(
        "--debug",
        action="store_true",
        help="Run in debug mode"
    )

    args = parser.parse_args()

    # Ensure alerts directory exists
    ALERTS_DIR.mkdir(parents=True, exist_ok=True)

    print("=" * 80)
    print("  PRODUCT ALERTS API SERVER")
    print("=" * 80)
    print(f"\nüåê Server starting on http://{args.host}:{args.port}")
    print(f"üìÅ Alerts directory: {ALERTS_DIR.absolute()}")
    print(f"\nüì° Available endpoints:")
    print(f"   GET  /api/health              - Health check")
    print(f"   GET  /api/alerts/latest       - Get latest alerts")
    print(f"   GET  /api/alerts/<date>       - Get alerts by date (YYYY-MM-DD)")
    print(f"   GET  /api/alerts/list         - List all available dates")
    print(f"   GET  /api/alerts/summary      - Get summary of all alerts")
    print(f"\nüöÄ Press Ctrl+C to stop the server\n")
    print("=" * 80)

    app.run(
        host=args.host,
        port=args.port,
        debug=args.debug
    )


if __name__ == "__main__":
    main()
